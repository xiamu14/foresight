---
title: 浏览器的运行原理
description: 快速了解浏览器的运行原理
cover: 51tu-1676278052367.avif?w=2074&h=1378
tags: browser|principle
status: common
date: 2023-02-13
---

## 浏览器结构图

浏览器结构可以简单分为`用户界面`，`浏览器引擎`，`渲染引擎`。

- 用户界面：用于展示除标签页以外其他用户界面内容
- 浏览器引擎：用于在用户界面和渲染引擎间传递数据
  - 数据存储持久层，帮助浏览器存储各种数据
- 渲染引擎：负责渲染用户请求的页面内容
  渲染器下有很多小的模块：比如用于网络请求的网络模块，用于解析和执行 JS 的 js 解释器等

图示如下:

![浏览器结构图](ugfx-1676280597992.png?w=856&h=788)

## 浏览器内核-渲染引擎

渲染引擎可以说是一个浏览器的核心，往往称为浏览器的内核。不同浏览器使用的内核也不大一样，比如 chrome，Edge，Opera 使用 Blink 内核（基于 Blink 优化的），Safari 使用 webkit 内核。

换个角度来拆解下浏览器的组成：浏览器是运行在操作系统上的应用程序。每个应用程序必须启动一个`进程`来执行器功能，进程会创建`线程`来执行很多小功能。

- 进程：是操作系统进行资源分配和调度的基本单元，可以申请和拥有计算机资源，进程是程序的基本执行实体。
- 线程：是操作系统能够进行运算调度的最小单位，一个进程中可以并发多个线程，每条线程并行执行不同的任务。

浏览器是多进程的应用程序，进程间通过 IPC 通信。

如图所示：
![浏览器多进程结构](-gHS-1676283050001.png?w=2386&h=1310)

- 浏览器进程：负责 Chrome 浏览器除标签页外的用户界面，包括地址栏、书签、后退和前进按钮，以及负责与其他进程协调工作
- 网络进程：负责发起接受网络请求
- GPU 进程：负责整个浏览器界面的渲染
- 渲染器进程：用于显示 tab 标签内的所有内容，浏览器默认情况会为每个标签页创建一个渲染器进程（根据不同进程模型，四种进程模型）

### 浏览器输入地址时过程

1. 在地址栏输入内容时，浏览器进程的 UI 线程会捕捉到地址，则会启动一个网络线程来请求 DNS 进行域名解析
2. 网络线程接着会连接服务器获取数据
3. 当网络线程获取到数据后，会通过 'SafeBrowsing' （google 内部的站点检测系统）来检查站点是否是‘恶意站点’（是则显示恶意站点提示页面）。通过检测后网络线程会通知 UI 线程。
4. 然后 UI 线程会创建一个渲染器进程（Renderer Process）来渲染页面。
5. 浏览器进程通过 IPC 管道将数据传输给渲染器线程，进入渲染流程

#### 渲染流程

渲染器进程接受到的数据就是 html，渲染器进程的核心任务就是把 html、css、js、image 等资源渲染成用户可以交互的 web 页面。

1. 渲染器进程的主线程（Main Thread）将 html 进行解析，构造 `DOM 数据结构`。html 代码中往往会引入一些额外的资源，比如图片、CSS、JS 脚本等。图片和 CSS 这些资源需要通过网络下载或从缓存中读取，这些资源不会阻塞 html 的加载，因为他们不会影响 DOM 的生成。但 script 标签能修改 DOM（比如 document.write 方法），所以会先停止 html 解析，先加载运行 JS。[script 的特性，defer 和 async 可以改变]
2. html 解析后会得到 DOM 树，然后主线程需要解析 CSS，并确定每个 DOM 节点的计算样式。
3. 在知道每个节点的样式以后，接下来需要知道节点放在哪个位置，也就是节点的座标以及该节点需要该节点需要占用多大的区域。这个阶段被称为 `Layout布局`。主线程通过遍历 DOM 和计算好的样式来生成 `Layout Tree`。`Layout Tree` 上每个节点都记录了 x，y 座标和边框尺寸。（DOM Tree 和 Layout Tree 并不一一对应，比如 display:none, ::before 等伪类）
4. 然后还需要知道按什么顺序来绘制节点，比如 z-index 属性会影响节点绘制的层级关系。主线程遍历 Layout Tree 创建一个绘制记录表（Paint Record）,这个表记录了绘制的顺序，这个阶段称为“绘制”（paint）
5. 知道元素的位置以后，就要将这些信息转化为像素点，这个过程称为“栅格化”（Rastering）, Chrome 现在使用的“栅格化”方式叫做“合成”（Composting）。合成是将页面各个部分分成多个图层，分别进行栅格化，并在合成器线程（Compositor Thread）中单独合成页面的技术。简单来说就是页面所有元素按照某种规则进行分图层，并把图层都栅格化好了，然后只需要把可视区的内容组合成一帧展示给用户即可。
   1. 合成器线程分图层以后，再切分为更小的图片（tiles）信息，传递给栅格线程，进行栅格化
   2. 栅格化完成后，合成器线程会获得栅格线程传过来的“draw quads”图块信息，根据这些信息合成器线程合成一个合成器帧，然后将该合成器帧通过 IPC 传回给浏览器进程，浏览器进程再传到 GPU 进行渲染。

![](TKGa-1676592438703.png?w=1728&h=854)

> 当改变一个元素尺寸时，会重新进行样式计算（Computed Style），布局（Layout），绘制（Paint）即后面所有的流程，这种行为称为重排。
>
> 当我们改变某个元素的颜色属性时，不会触发 Layout，但还是会触发样式计算和绘制，这个就是重绘。
>
> 重排和重绘都是运行在渲染器进程的主线程中，JS 也是运行 JS 主线程中。因此会出现抢占运行时间的问题。如果页面不断重排重绘，JS 运行时间过长，就会出现卡顿。
>
> 优化手段：使用 requestAnimationFrame()，React Fiber 使用 RAF 进行优化。减少重绘重排，CSS 中的 Transform 动画运行在合成器线程。
